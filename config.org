:PROPERTIES:
:ID:       a7bc5be7-4a33-4a78-98a6-e922ea9a02fc
:END:
#+TITLE: Josh McIntosh's emacs config
#+filetags: :project:

* General setup
:PROPERTIES:
:ID:       36dcddeb-f7bf-47c0-8609-c605c74fdbdc
:END:

#+begin_src emacs-lisp :tangle yes
(require 'helm-lib)
#+end_src

Lets dress to the 9s. I'm rockin doom, so lets put on something nice.

#+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-tomorrow-night)
#+end_src

I have a little bit of config that lives on the work side, so lets load it if
it's there. No worries if it isn't.

#+BEGIN_SRC emacs-lisp :tangle yes
(let ((fname (concat (file-name-as-directory doom-private-dir) "+work-config.org")))
  (if (file-exists-p fname)
      (org-babel-load-file fname)))

#+END_SRC

Lets make sure we configure evil-undo-system correctly.
#+begin_src emacs-lisp :tangle yes
(setq evil-undo-system 'undo-fu)
#+end_src
** Emacs Start Up Profiler
:PROPERTIES:
:ID:       6ac025cf-231d-48a6-a1a3-c313598c225c
:END:
#+begin_src emacs-lisp :tangle yes
(use-package! esup)
#+end_src

* ERC
:PROPERTIES:
:ID:       e3ebfb76-bb7c-4dc1-bf77-6065fecc4ab5
:END:
IRC is great (ok, really, I don't use it as much as I used to). Turns out emacs
can do IRC too! A few different ways! I use ERC!

#+begin_src emacs-lisp :tangle yes
(use-package! erc
  :custom
  (erc-autojoin-channels-alist '(("freenode.net" "#ubuntu" "#emacs" "#python"
                                  "org-mode")))
  (erc-autojoin-timing 'ident)
  (erc-fill-function 'erc-fill-static)
  (erc-fill-static-center 22)
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
  (erc-lurker-threshold-time 43200)
  (erc-prompt-for-nickserv-password nil)

  :config
  (add-to-list 'erc-modules 'notifications)
  (add-to-list 'erc-modules 'spelling)
  (erc-services-mode 1)
  (erc-update-modules))
#+end_src
* Mail
:PROPERTIES:
:ID:       501fac60-2a59-4cfe-a121-71c460dfc5ad
:END:
** GNUS
:PROPERTIES:
:ID:       563a8e77-2ada-4025-96e6-dd5523978c3b
:END:
The venerable reader.
*** Keybindings
:PROPERTIES:
:ID:       26baf050-8efe-4e69-a302-3607a8c72ae2
:END:
Here's some top-level keybindings:
#+BEGIN_SRC emacs-lisp :tangle yes
(map! :leader
      :prefix "o"
      :desc "GNUS" "g" #'gnus
      )
#+END_SRC
** Notmuch
:PROPERTIES:
:ID:       093cf91e-6a46-4f1a-883e-74cde9141280
:END:
Notmuch is a mail sorting/tagging engine.
#+begin_src emacs-lisp :tangle yes
(use-package! notmuch)
#+end_src

* GTD
:PROPERTIES:
:ID:       b4a9fe5a-7e7d-4179-b60d-02c55d61a6c7
:END:
** Introduction
:PROPERTIES:
:ID:       6ee06332-5975-4a42-8136-d2b6a5e47fcb
:END:
All of this takes place after loading org.
#+begin_src emacs-lisp :tangle yes
(after! org
#+end_src

I have a config that is more-or-less stolen from [[http://doc.norang.ca/org-mode.html][Norang's org-mode setup]].

Let's set a default task and org-directory if needed. We'll also establish what
org-modules we want enabled.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-modules (append org-modules '(org-habit org-crypt org-eshell)))

  (unless (boundp 'jm/organization-task-id)
    (setq jm/organization-task-id "64883bab-0842-4e8e-8fb6-9eff4c389cc3"))

  (setq jm/daily-qs-id "700295d8-1e67-4071-8587-ed254529422f")

  (unless (boundp 'org-directory)
    (setq org-directory "~/org/"))

  (unless (boundp 'org-agenda-files)
    (setq org-agenda-files (list org-directory)))

#+END_SRC
** Org-mode mandatory IDs
:PROPERTIES:
:ID:       21bcf4da-58bb-449b-9699-8fb127e8f8ae
:END:
#+begin_src emacs-lisp :tangle yes
(defun +org-auto-id-add-to-headlines-in-file ()
  "Add ID property to the current file and all its headlines."
  (when (and (or (eq major-mode 'org-mode)
                 (eq major-mode 'org-journal-mode))
             (eq buffer-read-only nil))
    (save-excursion
      (widen)
      (goto-char (point-min))
      (org-id-get-create)
      ;; (org-map-entries #'org-id-get-create)
      )))

(add-hook 'before-save-hook #'+org-auto-id-add-to-headlines-in-file)
#+end_src
** Misc Custom Packages and config
:PROPERTIES:
:ID:       3d011f95-ec80-4fd3-bdb4-2e1997cd7ba8
:END:
*** yequake
:PROPERTIES:
:ID:       ab1cce50-b4c2-458c-a13e-a16c1cf16e2f
:END:
#+begin_src emacs-lisp :tangle yes
(defun jm/org-roam-dailies-find-today ()
  (interactive)
  (org-roam-dailies-find-today)
  (current-buffer))
(use-package! yequake
  :custom
  (yequake-frames '(("Agenda" .
                     ((width . 0.75)
                      (height . 0.5)
                      (alpha . 0.95)
                      (buffer-fns . (jm/org-roam-dailies-find-today split-window-horizontally jm/org-agenda))
                      (frame-parameters . ((undecorated . t))))))))

(defun jm/org-agenda-yequake ()
  (interactive)
  (yequake-toggle "Agenda"))

(map! :leader
      :desc "Org Agenda (toggle)" :n "a" #'jm/org-agenda-yequake)
#+end_src
** PKM
:PROPERTIES:
:ID:       2f6514bc-d0d9-4a45-940b-f94c596f4c3b
:END:
*** org-roam
:PROPERTIES:
:ID:       19496fa9-cd4e-42f7-bb59-9bb76bf07c68
:END:
I've come to like the 'org-roam' package. I'm trying to build some momentum in
zettelkasten data organization, and this seems promising.

It turns out org-roam has been added as a feature to doom-emacs, so some of my
config here is obsolete :-)

**** org-roam directory
:PROPERTIES:
:ID:       10a552c2-0568-44dc-b210-355efab7c4c4
:END:
I use a scheme to se the directory based on a variable I set. This _may_
be set from other configs, ie. from a work specific or private config.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless (boundp 'jm/org-roam-directory)
  (setq jm/org-roam-directory (concat (file-name-as-directory org-directory) "KB")))
(setq org-roam-directory jm/org-roam-directory)
#+END_SRC
**** org-roam key mapping
:PROPERTIES:
:ID:       07238d52-83e5-4c49-a219-fe7d2ee0be1d
:END:
I set up some higher-level keys in the doom-emacs "notes" prefix.

#+begin_src emacs-lisp :tangle yes

(map! :leader
      :prefix "n"
      :desc "Org-Roam Insert" "i" #'org-roam-insert
      :desc "Org-Roam Find" "/" #'org-roam-find-file
      :desc "Org-Roam Buffer" "b" #'org-roam)

#+end_src
**** org-roam capture
:PROPERTIES:
:ID:       7cfc824f-f19f-4cb9-b835-da3a60c4ddc0
:END:

#+begin_src emacs-lisp :tangle yes
(unless (boundp 'jm/org-roam-capture-templates)
  (setq jm/org-roam-capture-templates (list)))

(defvar jm/capture-date-format (list "%Y" "%Y_Q%q" "%Y_%m" "%Y_%m_W%U" "%Y_%m_%d")
  "OLP path to follow for capturing date info.")
(defvar jm/capture-date-file (concat (file-name-as-directory org-roam-directory) "journal.org")
  "Capture file to use for journaling.")

(defun jm/capture-date-hierarchy ()
  "Ensure we have approrpiate OLP defined for the given date-based capture."
  (let* ((olp (mapcar 'format-time-string jm/capture-date-format))
         (target (append (list 'file+olp jm/capture-date-file) (cl-copy-list olp))))
    (set-buffer (org-capture-target-buffer jm/capture-date-file))
    (goto-char (point-min-marker))
    (let (spent)
      (dolist (header olp spent)
        (add-to-list 'spent header t)
        (condition-case ex
            (goto-char (org-find-olp spent t))
          ('error
           (goto-char (or (org-find-olp (butlast spent) t) (point-max-marker)))
           (org-insert-heading nil nil t)
           (dotimes (i (- (length spent) 1))
             (org-demote))
           (insert header "\n")))))
    (org-roam-capture--put :if-new target)
    (org-capture-set-target-location target)))

(add-to-list 'jm/org-roam-capture-templates
             '("d" "default" plain "%?"
               :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
               :unnarrowed t))
(add-to-list 'jm/org-roam-capture-templates
             '("c" "calendarish" plain "%?"
               :if-new (file+function "journal.org" jm/capture-date-hierarchy)))

(setq org-roam-capture-templates jm/org-roam-capture-templates)
(setq jm/org-roam-capture-templates '())
#+end_src

**** org-roam dailies
:PROPERTIES:
:ID:       f5a8e64f-c5e1-496b-84bc-88bcb4e86d69
:END:
I'd like to track not only at the daily capacity, but also potentially at:
- weekly
- monthly
- quarterly
- yearly

#+begin_src emacs-lisp :tangle yes :noweb yes
(setq org-roam-dailies-directory "journals")
(unless (boundp 'jm/org-roam-dailies-capture-templates)
  (setq jm/org-roam-dailies-capture-templates (list)))

(setq jm/head-template "#+title: %s \n([[elisp:(jm/goto-date)][Go to %s]])\n\n* Accomplishments")

(defun jm/add-daily-lookahead-props ()
  (if-let ((dateform (org-capture-get :jm-time-format))
           (date (format-time-string "%Y_%m_%d" (org-capture-get :default-time)))
           (keys (org-capture-get :jm-keys)))

       (if (and  (not (org-property-values "DATEFORM"))
                 (not (org-buffer-narrowed-p)))
           (progn
             (goto-char (point-min))
             (org-set-property "DATEFORM" dateform)
             (org-set-property "DATE" date)
             (org-set-property "KEYS" keys)))))

(add-hook 'org-roam-dailies-find-file-hook #'jm/add-daily-lookahead-props)

(let* ((jm/head (format jm/head-template "%<%Y_%m_%d>" "Weekly")))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               '("d" "dailies"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("dd" "default" plain "" :if-new
                 (file+head "%<%Y_%m_%d>.org" ,jm/head)
                 :unnarrowed t
                 :jm-time-format "%Y_%m_W%U" :jm-keys "ww"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("da" "daily accomplishments" entry "* %?" :if-new
                 (file+head+olp "%<%Y_%m_%d>.org" ,jm/head ("Accomplishments"))
                 :jm-time-format "%Y_%m_W%U" :jm-keys "ww")))
<<weeklies>>
<<monthlies>>
<<quarterlies>>
<<yearlies>>

(setq org-roam-dailies-capture-templates jm/org-roam-dailies-capture-templates)
(setq jm/org-roam-dailies-capture-templates '())

#+end_src

This function is close to org-roam-dailies--capture, but allowing for key
to be inserted.

#+begin_src emacs-lisp :tangle yes
(defun jm/goto-date ()
  (if-let* ((date (car (org-property-values "DATE")))
            (keys (car (org-property-values "KEYS")))
            (time (date-to-time (concat date "T12:00:00+0700")))
            (title (format-time-string (car (org-property-values "DATEFORM")) time)))
      (let ((node (or (org-roam-node-from-title-or-alias title)
                      (org-roam-node-create))))
        (if (org-roam-node-id node)
            (org-roam-node-visit node)
          (org-roam-capture-
             :node node
             :templates org-roam-dailies-capture-templates
             :keys keys
             :props  (list :finalize 'find-file
                           :override-default-time time))))
    (error "Failed to capture all of date keys time and title")))

  (defun jm/roam-dlys (&optional arg keys time-format time)
    "Find an Org-roam node and insert (where the point is) an \"id:\" link to it.
FILTER-FN is a function to filter out nodes: it takes an `org-roam-node',
and when nil is returned the node will be filtered out."
    (interactive "p")
    (let ((org-roam-directory (expand-file-name org-roam-dailies-directory org-roam-directory)))
      (unwind-protect
          ;; Group functions together to avoid inconsistent state on quit
          (atomic-change-group
            (let* ((time (or
                          time
                          (org-capture-get :default-time) (current-time)))
                   (timestring (format-time-string
                                (or time-format
                                    (org-capture-get :jm-time-format)
                                    "%Y-%m-%d")
                                time))
                   (node (or (org-roam-node-from-title-or-alias timestring)
                             (org-roam-node-create)))
                   (description (or (org-roam-node-title node) timestring)))
              (if (org-roam-node-id node)
                  (let ((link (org-link-make-string
                               (concat "id:" (org-roam-node-id node))
                               description)))
                    (if arg (insert link)
                      link))
                (progn
                  (org-roam-capture-
                   :node node
                   :templates org-roam-dailies-capture-templates
                   :keys (or keys (org-capture-get :jm-keys))
                   :props (append
                           (when arg
                             (list :finalize 'insert-link))
                           (list :insert-at (point-marker)
                                 :link-description description
                                 :override-default-time time)))
                  (when (not arg)
                    (org-link-make-string
                     (concat "id:" (org-roam-node-id (org-roam-node-from-title-or-alias timestring)))
                     description))))))
        (deactivate-mark))))

  (defun jm/roam-dlys-d(&optional arg time)
    (interactive "p")
    (jm/roam-dlys arg "dd" "%Y_%m_%d" (or time (current-time))))
  (defun jm/roam-dlys-w(&optional arg time)
    (interactive "p")
    (jm/roam-dlys arg "ww" "%Y_%m_W%U" (or time (current-time))))
  (defun jm/roam-dlys-m(&optional arg time)
    (interactive)
    (jm/roam-dlys arg "mm" "%Y_%m" (or time (current-time))))
  (defun jm/roam-dlys-q(&optional arg time)
    (interactive "p")
    (jm/roam-dlys arg "uu" "%Y_Q%q" (or time (current-time))))
  (defun jm/roam-dlys-y(&optional arg time)
    (interactive "p")
    (jm/roam-dlys arg "yy" "%Y" (or time (current-time))))
#+end_src

***** Weeklies
:PROPERTIES:
:ID:       a6997b0d-6241-416a-8b27-8861fba3e4c2
:END:
#+name: weeklies
#+begin_src emacs-lisp :tangle yes
(let* ((jm/head (format jm/head-template "%<%Y_%m_W%U>" "Monthly")))

  (add-to-list 'jm/org-roam-dailies-capture-templates
               '("w" "weekly"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("ww" "default" plain "" :if-new
                 (file+head "%<%Y_%m_W%U>.org" ,jm/head)
                 :jm-time-format "%Y_%m" :jm-keys "mm"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("wa" "weekly accomplishments" entry "* %?" :if-new
                 (file+head+olp "%<%Y_%m_W%U>.org" ,jm/head ("Accomplishments"))
                 :jm-time-format "%Y_%m" :jm-keys "mm")))

#+end_src
***** Monthlies
:PROPERTIES:
:ID:       c6f957ac-ded2-481d-ac64-104c96610321
:END:
#+name: monthlies
#+begin_src emacs-lisp :tangle yes
(let* ((jm/head (format jm/head-template "%<%Y_%m>" "Quarterly")))

  (add-to-list 'jm/org-roam-dailies-capture-templates
               '("m" "Monthly"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("mm" "default" plain "" :if-new
                 (file+head "%<%Y_%m>.org" ,jm/head)
                 :jm-time-format "%Y_Q%q" :jm-keys "uu"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("ma" "monthly accomplishments" entry "* %?" :if-new
                 (file+head+olp "%<%Y_%m>.org" ,jm/head ("Accomplishments"))
                  :jm-time-format "%Y_Q%q" :jm-keys "uu")))

#+end_src

***** Quarterlies
:PROPERTIES:
:ID:       42e0c8bd-b5b9-4a77-9bfc-2a381689ca9a
:END:
#+name: quarterlies
#+begin_src emacs-lisp :tangle yes
(let* ((jm/head (format jm/head-template "%<%Y_Q%q>" "Yearly")))

  (add-to-list 'jm/org-roam-dailies-capture-templates
               '("u" "quartlies"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("uu" "default" plain "" :if-new
                 (file+head "%<%Y_Q%q>.org" ,jm/head)
                 :jm-time-format "%Y" :jm-keys "yy"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("ua" "quarterly accomplishments" entry "* %?" :if-new
                 (file+head+olp "%<%Y_Q%q>.org" ,jm/head ("Accomplishments"))
                  :jm-time-format "%Y" :jm-keys "yy")))

#+end_src

***** Yearlies
:PROPERTIES:
:ID:       5d038165-ac6c-4ee8-8f62-6cd9f2c253aa
:END:
#+name: yearlies
#+begin_src emacs-lisp :tangle yes
(let* ((jm/head "#+title: %<%Y>\n\n* Accomplishments"))

  (add-to-list 'jm/org-roam-dailies-capture-templates
               '("y" "yearlies"))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("yy" "default" plain "" :if-new
                 (file+head "%<%Y>.org" ,jm/head)))
  (add-to-list 'jm/org-roam-dailies-capture-templates
               `("ya" "yearly accomplishments" entry "* %?" :if-new
                 (file+head+olp "%<%Y>.org" ,jm/head ("Accomplishments")))))

#+end_src
**** Tags section in  org-roam-buffer
:PROPERTIES:
:ID:       c35ebbcd-172a-4330-9deb-68210fd316d4
:END:
This will display tags section with any nodes tagged as the source node is named. Eg. if you have a node 'people' and a tag 'people', it will show the nodes tagged 'people' in the sidebar for the node 'people'.

#+begin_src emacs-lisp :tangle yes
(cl-defstruct (jm/org-roam-tag (:constructor jm/org-roam-tag-create)
                               (:copier nil))
  source-node target-node
  point properties tag)

(cl-defmethod org-roam-populate ((tag jm/org-roam-tag))
  (setf (jm/org-roam-tag-source-node tag)
        (org-roam-populate (jm/org-roam-tag-source-node tag))
        (jm/org-roam-tag-target-node tag)
        (org-roam-populate (jm/org-roam-tag-target-node tag))
        (jm/org-roam-tag-point tag)
        (org-roam-node-point (jm/org-roam-tag-source-node tag))
        (jm/org-roam-tag-properties tag)
        (org-roam-node-properties (jm/org-roam-tag-source-node tag)))
  tag)

(defun jm/org-roam-tags-get-2 (node)
  "Search for tags that reference the tile or alias of a node"
  (let ((tags (org-roam-db-query
               [:select :distinct [node_id]
                :from tags
                :where (like tag $s1)]
               (org-roam-node-title node))))
    (cl-loop for a-tag in tags
             collect (pcase-let ((`(,id ,tag) a-tag))
                       (org-roam-populate
                        (jm/org-roam-tag-create
                         :source-node (org-roam-node-create :id id)
                         :target-node node
                         :tag (org-roam-node-title node)))))
    )
  )

(defun jm/org-roam-tags-get (node &optional and-aliases)
  "Search for tags that reference the tile or alias of a node"
  (let* (tags
         (node (org-roam-populate node))
         (get-ids (lambda (see) (mapcar #'car (org-roam-db-query
                                               [:select :distinct [node_id]
                                                :from tags :where (like tag $s1)]
                                               (format "%%%s%%" see))))))
    (add-to-list 'tags (cons (org-roam-node-title node) (funcall get-ids (org-roam-node-title node))))
    (when and-aliases
      ;; Extract aliases from the node (assumed populated or populate here?)
      (let ((aliases (org-roam-node-aliases node)))
        (dolist (alias aliases)
          (add-to-list 'tags (cons alias (funcall get-ids alias))))))

    ;; loop over alist,
    (cl-loop for (alias . ids) in tags
             append (cl-loop for id in ids
                             collect (org-roam-populate
                                      (jm/org-roam-tag-create
                                       :source-node (org-roam-node-from-id id)
                                       :target-node node
                                       :tag alias))))))

(defun jm/org-roam-tags-sort (a b)
  (string< (org-roam-node-title (jm/org-roam-tag-source-node a))
           (org-roam-node-title (jm/org-roam-tag-source-node b))))

(defun jm/org-roam-tags-section (node)
  "The tags section for NODE."
  (when-let ((tags (seq-sort #'jm/org-roam-tags-sort (jm/org-roam-tags-get node))))
    (magit-insert-section (org-roam-tags)
      (magit-insert-heading "Tags:")
      (dolist (tag tags)
        (org-roam-node-insert-section
         :source-node (jm/org-roam-tag-source-node tag)
         :point (jm/org-roam-tag-point tag)
         :properties (jm/org-roam-tag-properties tag)
         ))
      (insert ?\n))))

#+end_src


*** md-roam
:PROPERTIES:
:ID:       8d9c8b30-a9b9-4d7e-86e2-2f563d9f6622
:END:
[[https://github.com/nobiot/md-roam][Nobiot's md-roam]] provides the ability to format your notes in markdown but
still use the cross-ability of org-roam. I'm considering use of this for
compatability with the [[http://anagora.org/][angora]]. To be fair, though... I really like org-mode, so
this might be a tough sell.
#+begin_src emacs-lisp :tangle yes
(use-package! md-roam)

(setq org-roam-file-extensions '("org" "md"))
(defun jm/toggle-file-extensions (arg)
  (interactive "p")
  (cond ((eq arg 4) (setq org-roam-file-extensions '("org" "md")))
        ((eq arg 16) (setq org-roam-file-extensions '("md" "org" )))
        (t (setq org-roam-file-extensions (reverse org-roam-file-extensions))))
  (message "Org-Roam format is now %s" (car org-roam-file-extensions)))

(map! :leader
      :prefix "t"
      :desc " org-roam file format" "m" #'jm/toggle-file-extensions)

#+end_src
*** vulpea
:PROPERTIES:
:ID:       f0666b54-d43c-4779-b3e3-30e4a78d5f73
:END:
[[https://github.com/d12frosted/vulpea][Vulpea]] appears to be some extra machination around org-roam. I'm still testing
it out.

#+begin_src emacs-lisp :tangle yes
(use-package! vulpea)
#+end_src
**** Category naming for sane agenda views of roam
:PROPERTIES:
:ID:       6c4b58f9-95cd-4c57-9ee5-6296180acb2e
:END:
Based on [[https://d12frosted.io/posts/2020-06-24-task-management-with-roam-vol2.html][This blog post]].
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-prefix-format
      '((agenda . " %i %(jm/agenda-category 12)%?-12t% s")
        (todo . " %i %(jm/agenda-category 12) ")
        (tags . " %i %(jm/agenda-category 12) ")
        (search . " %i %(jm/agenda-category 12) ")))

(defun jm/buffer-prop-get (name)
  "Get a buffer property called NAME as a string."
  (org-with-point-at 1
    (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                             (point-max) t)
      (let ((value (string-trim
                    (buffer-substring-no-properties
                     (match-beginning 1)
                     (match-end 1)))))
        (unless (string-empty-p value)
          value)))))


(defun jm/agenda-category (&optional len)
  "Get category of item at point for agenda.

Category is defined by one of the following items:

- CATEGORY property
- TITLE keyword
- TITLE property
- filename without directory and extension

When LEN is a number, resulting string is padded right with
spaces and then truncated with ... on the right if result is
longer than LEN.

Usage example:

  (setq org-agenda-prefix-format
        '((agenda . \" %(jm/agenda-category) %?-12t %12s\")))

Refer to `org-agenda-prefix-format' for more information."
  (let* ((file-name (when buffer-file-name
                      (file-name-sans-extension
                       (file-name-nondirectory buffer-file-name))))
         (title (jm/buffer-prop-get "title"))
         (category (org-get-category))
         (result
          (or (if (and
                   title
                   (string-equal category file-name))
                  title
                category)
              "")))
    (if (numberp len)
        (s-truncate len (s-pad-right len " " result))
      result)))
#+end_src
**** Agenda management
:PROPERTIES:
:ID:       3e395390-a558-4580-9700-ddae26184531
:END:
d12frosted has referenced org-agenda management on  his [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][blog]], providing
a setup for using org-agenda with org-roam.

#+begin_src emacs-lisp :tangle yes
(defun jm/project-p ()
  "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
  (org-element-map                          ; (2)
       (org-element-parse-buffer 'headline) ; (1)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match))                     ; (3)

(add-hook 'find-file-hook #'jm/project-update-tag)
(add-hook 'before-save-hook #'jm/project-update-tag)

(defun jm/project-update-tag ()
  "Update PROJECT tag in the current buffer."
  (when (and (not (active-minibuffer-window))
             (progn (goto-char (point-min)) (org-roam-node-at-point)))
    (save-excursion
      (goto-char (point-min))
      ;; jm: HACK - recompute filetags to read below.
      (org-set-regexps-and-options t)
      (let* ((tags (map 'list #'org-no-properties org-file-tags))
             (original-tags tags))
        (if (and (jm/project-p)
                 (not (string-prefix-p "b/" (org-roam-node-title
                                        (org-roam-node-at-point)))))
            (setq tags (append (list "project") tags))
          (setq tags (remove "project" tags)))
        (unless (eq original-tags tags)
          (apply #'org-roam-tag-add (list (seq-uniq tags))))))))

(defun jm/project-files ()
  "Return a list of note files containing 'project' tag." ;
  (seq-uniq
   (append (list
            (concat (file-name-as-directory org-directory) "gcal.org")
            (concat (file-name-as-directory org-directory) "refile.org"))
           (seq-map
            #'car
            (org-roam-db-query
             [:select [nodes:file]
              :from tags
              :left-join nodes
              :on (= tags:node-id nodes:id)
              :where (like tag (quote "%\"project\"%"))])))))

(defun jm/agenda-files-update (&rest _)
  "Update the value of `org-agenda-files'."
  (setq org-agenda-files (jm/project-files)))

(advice-add 'org-agenda :before #'jm/agenda-files-update)
#+end_src

*** org-transclusion
:PROPERTIES:
:ID:       1f60ad5a-071b-4123-8f9e-17fbb29f159e
:END:
#+begin_src emacs-lisp :tangle yes
(use-package! org-transclusion)

(general-auto-unbind-keys)
(map! :localleader
      :map org-mode-map
      :prefix ("T" . "Transclusion")
       "a" #'org-transclusion-add
       "A" #'org-transclusion-add-all
       "d" #'org-transclusion-remove
       "D" #'org-transclusion-remove-all
       "h" #'org-transclusion-promote-subtree
       "l" #'org-transclusion-demote-subtree
       "m" #'org-transclusion-make-from-link
       "o" #'org-transclusion-open-source
       "O" #'org-transclusion-move-to-source
       "r" #'org-transclusion-refresh
       "s" #'org-transclusion-live-sync-start
       "S" #'org-transclusion-live-sync-exit)
(general-auto-unbind-keys t)

#+end_src

** 'TODO' states
:PROPERTIES:
:ID:       4e88dac9-9edb-4d7f-823a-ec5e1aeb3610
:END:
Here are some of the TODO states and faces I keep around.
#+BEGIN_SRC  emacs-lisp :tangle yes
(setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                          (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")))

;; Cribbed from doom-emacs org layer
  (with-no-warnings
    (custom-declare-face '+org-todo-active '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
    (custom-declare-face '+org-todo-project '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
    (custom-declare-face '+org-todo-onhold '((t (:inherit (bold warning org-todo)))) ""))

(setq org-todo-keyword-faces
        '(("NEXT" . +org-todo-active)
          ("HOLD" . +org-todo-onhold)))
;; (setq org-todo-keyword-faces '(("TODO" :foreground "red" :weight bold)
;;                                ("NEXT" :foreground "blue" :weight bold)
;;                                ("DONE" :foreground "forest green" :weight bold)
;;                                ("WAITING" :foreground "orange" :weight bold)
;;                                ("HOLD" :foreground "magenta" :weight bold)
;;                                ("CANCELLED" :foreground "forest green" :weight bold)
;;                                ("MEETING" :foreground "forest green" :weight bold)
;;                                ("PHONE" :foreground "forest green" :weight bold)))

(setq org-use-fast-todo-selection t)
#+END_SRC

When tags move from or to states, we want to make sure tags are moved
appropriately.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-todo-state-tags-triggers '(("CANCELLED" ("CANCELLED" . t))
                                     ("WAITING" ("WAITING" . t))
                                     ("HOLD" ("WAITING") ("HOLD" . t))
                                     (done ("WAITING") ("HOLD"))
                                     ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                                     ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                                     ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))

#+END_SRC
*** TODO need to adjust my faces...
:PROPERTIES:
:ID:       2f8d1219-407c-4f95-82cd-08f6473b30ef
:END:
** Capture
:PROPERTIES:
:ID:       19a0f630-6201-477a-9de0-b3ce6a74d31d
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(setq +org-capture-todo-file "refile.org")
(unless (boundp 'jm/org-capture-templates)
  (setq jm/org-capture-templates (list)))
(add-to-list 'jm/org-capture-templates
             `("t" "todo" entry (file ,(concat (file-name-as-directory org-directory) "refile.org"))
               "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("d" "Daily" entry (file+olp+datetree ,(concat (file-name-as-directory org-directory) "diary.org"))
               (file ,(concat (file-name-as-directory doom-private-dir) "templates/daily.org_template")))
             'append)

(add-to-list 'jm/org-capture-templates
             `("r" "respond" entry (file ,(concat (file-name-as-directory org-directory) "refile.org"))
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("n" "note" entry (file ,(concat (file-name-as-directory org-directory) "refile.org"))
               "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("p" "org-protocol" entry (file ,(concat (file-name-as-directory org-directory) "refile.org"))
               "* TODO review %^{Title}\nSource:%u, %c\n" :immediate-finish t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("L" "org-protocol link" entry (file ,(concat (file-name-as-directory org-directory) "refile.org"))
               "* TODO %? [[%:link][%:description]] \nCaptured on: %U" :immediate-finish t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("m" "Meeting" entry (file+olp+datetree ,(concat (file-name-as-directory org-directory) "diary.org"))
               "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
             'append)

(add-to-list 'jm/org-capture-templates
             `("w" "Review: Weekly Review" entry (file+olp+datetree ,(concat (file-name-as-directory org-directory) "reviews.org"))
               (file ,(concat doom-private-dir "templates/weeklyreviewtemplate.org")))
             'append)

(setq org-capture-templates jm/org-capture-templates)


#+END_SRC

This is a handy function for stripping out empty time logs if they happen:
#+begin_src emacs-lisp :tangle yes
  (defun jm/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at (point))))
  (add-hook 'org-clock-out-hook 'jm/remove-empty-drawer-on-clock-out 'append)

#+end_src
** Refiling
:PROPERTIES:
:ID:       12181d3c-73ae-4579-95fd-bf763dfeb62e
:END:
Here's some refile options for ya, and a norang function for refiles:

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-refile-targets '((org-agenda-files :maxlevel . 9))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm)

(defun jm/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'jm/verify-refile-target)

#+END_SRC
** Agenda
:PROPERTIES:
:ID:       f6a34725-144a-4326-ac09-f5ded5623678
:END:

*** org-super-agenda
:PROPERTIES:
:ID:       d1e00c5b-8954-411a-a24b-fe78724b0645
:END:
Super agenda helps to bucket items more practically.
#+begin_src emacs-lisp :tangle yes
;; (use-package! org-super-agenda)
;; (setq org-super-agenda-groups
;;         '((:name "Calendar entries"
;;            :time-grid t
;;            :property "calendar-id")
;;          (:name "Today"
;;            :time-grid t
;;            :todo "TODAY")))
;; (org-super-agenda-mode)
#+end_src
*** Custom config
:PROPERTIES:
:ID:       6c029ed7-f1a1-4d27-aaa5-4ee05e0a8a6b
:END:

Ok, a lot to unpack here. notably, this captures up what custom commands should
be listed, including the big agenda view.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-agenda-dim-blocked-tasks nil
      org-agenda-compact-blocks t
      org-agenda-start-day "-1d"
      org-agenda-span 6
      org-agenda-custom-commands '(("N" "Notes" tags "NOTE"
                                    ((org-agenda-overriding-header "Notes")
                                     (org-tags-match-list-sublevels t)))
                                   ("h" "Habits" tags-todo "STYLE=\"habit\""
                                    ((org-agenda-overriding-header "Habits")
                                     (org-agenda-sorting-strategy
                                      '(todo-state-down effort-up category-keep))))
                                   ("z" "Agenda"
                                    ((agenda "" nil)
                                     (tags "REFILE"
                                           ((org-agenda-overriding-header "Tasks to Refile")
                                            (org-tags-match-list-sublevels nil)))
                                     (tags-todo "-CANCELLED/!"
                                                ((org-agenda-overriding-header "Stuck Projects")
                                                 (org-agenda-skip-function 'jm/skip-non-stuck-projects)
                                                 (org-agenda-sorting-strategy
                                                  '(category-keep))))
                                     (tags-todo "-HOLD-CANCELLED/!"
                                                ((org-agenda-overriding-header "Projects")
                                                 (org-agenda-skip-function 'jm/skip-non-projects)
                                                 (org-tags-match-list-sublevels 'indented)
                                                 (org-agenda-sorting-strategy
                                                  '(category-keep))))
                                     (tags-todo "-CANCELLED/!NEXT"
                                                ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                                       (if jm/hide-scheduled-and-waiting-next-tasks
                                                                                           ""
                                                                                         " (including WAITING and SCHEDULED tasks)")))
                                                 (org-agenda-skip-function 'jm/skip-projects-and-habits-and-single-tasks)
                                                 (org-tags-match-list-sublevels t)
                                                 (org-agenda-todo-ignore-scheduled jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-deadlines jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-with-date jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-sorting-strategy
                                                  '(todo-state-down effort-up category-keep))))
                                     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                                ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                                       (if jm/hide-scheduled-and-waiting-next-tasks
                                                                                           ""
                                                                                         " (including WAITING and SCHEDULED tasks)")))
                                                 (org-agenda-skip-function 'jm/skip-non-project-tasks)
                                                 (org-agenda-todo-ignore-scheduled jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-deadlines jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-with-date jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-sorting-strategy
                                                  '(category-keep))))
                                     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                                                ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                                       (if jm/hide-scheduled-and-waiting-next-tasks
                                                                                           ""
                                                                                         " (including WAITING and SCHEDULED tasks)")))
                                                 (org-agenda-skip-function 'jm/skip-project-tasks)
                                                 (org-agenda-todo-ignore-scheduled jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-deadlines jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-with-date jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-sorting-strategy
                                                  '(category-keep))))
                                     (tags-todo "-CANCELLED+WAITING|HOLD/!"
                                                ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                                       (if jm/hide-scheduled-and-waiting-next-tasks
                                                                                           ""
                                                                                         " (including WAITING and SCHEDULED tasks)")))
                                                 (org-agenda-skip-function 'jm/skip-non-tasks)
                                                 (org-tags-match-list-sublevels nil)
                                                 (org-agenda-todo-ignore-scheduled jm/hide-scheduled-and-waiting-next-tasks)
                                                 (org-agenda-todo-ignore-deadlines jm/hide-scheduled-and-waiting-next-tasks)))
                                     (tags "-REFILE/"
                                           ((org-agenda-overriding-header "Tasks to Archive")
                                            (org-agenda-skip-function 'jm/skip-non-archivable-tasks)
                                            (org-tags-match-list-sublevels nil))))
                                    nil)))

#+END_SRC

I also found this digging through the norang configs, which I hadn't seen? huh.
#+begin_src emacs-lisp :tangle yes
(defun jm/org-auto-exclude-function (tag)
  "Automatic task exclusion in the agenda with / RET"
  (and (cond
        ((string= tag "hold")
         t)
        ((string= tag "farm")
         t))
       (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
#+end_src

I have a keymap direct to the big org-agenda view, and it calls this function.

#+begin_src emacs-lisp :tangle yes
  (defun jm/org-agenda (&optional arg)
    (interactive "P")
    (org-agenda arg "z"))
#+end_src

This is probably more about archiving, but I still need to dig deeper on that.

#+begin_src emacs-lisp :tangle yes
  (defun jm/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))

  (defun jm/mark-next-parent-tasks-todo ()
    "Visit each parent task and change NEXT states to TODO"
    (let ((mystate (or (and (fboundp 'org-state)
                            state)
                       (nth 2 (org-heading-components)))))
      (when mystate
        (save-excursion
          (while (org-up-heading-safe)
            (when (member (nth 2 (org-heading-components)) (list "NEXT"))
              (org-todo "TODO")))))))
#+end_src

** Time Clocking
:PROPERTIES:
:ID:       26abc204-2860-440a-8c36-22f35a3349d9
:END:
This is probably the beating heart of norangs config. there's a lot of time and
effort that goes into it.
#+BEGIN_SRC emacs-lisp :tangle yes
(org-clock-persistence-insinuate)

(setq org-clock-history-length 23
      org-clock-in-resume t
      org-clock-in-switch-to-state 'jm/clock-in-to-next
      org-drawers (quote ("PROPERTIES" "LOGBOOK"))
      org-log-done 'time
      org-clock-into-drawer t
      org-clock-out-when-done t
      org-clock-persist t
      org-clock-persist-query-resume nil
      org-clock-auto-clock-resolution (quote when-no-clock-is-running)
      org-clock-report-include-clocking-task t
      jm/keep-clock-running nil)

(defun jm/clock-in-to-next (_)
  "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (jm/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (jm/is-project-p))
      "TODO"))))

(defun jm/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun jm/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq jm/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (jm/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
                                        ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (jm/clock-in-organization-task-as-default)))))

(defun jm/punch-out ()
  (interactive)
  (setq jm/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun jm/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun jm/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when jm/keep-clock-running
            (jm/clock-in-default-task)))))))

(defun jm/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find jm/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun jm/clock-out-maybe ()
  (when (and jm/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (jm/clock-in-parent-task)))
(add-hook 'org-clock-out-hook 'jm/clock-out-maybe 'append)

(defun jm/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun jm/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))

(setq org-time-stamp-rounding-minutes (quote (1 1)))
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
              :min-duration 0
              :max-gap 0
              :gap-ok-around ("4:00"))))

(setq org-clock-out-remove-zero-time-clocks t)
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
(setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                    ("STYLE_ALL" . "habit"))))

#+END_SRC
** tags
:PROPERTIES:
:ID:       b485ca63-de3e-44d8-b555-368845d9bcea
:END:
this is a bit new to me (as in -- I cribbed it recently...).

#+begin_src emacs-lisp :tangle yes
; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("@errand" . ?e)
                            ("@cloud" . ?c)
                            ("@home" . ?H)
                            ("@farm" . ?f)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("PERSONAL" . ?P)
                            ("WORK" . ?W)
                            ("FARM" . ?F)
                            ("ORG" . ?O)
                            ("NORANG" . ?N)
                            ("crypt" . ?E)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?C)
                            ("FLAGGED" . ??)
                            ("SMALL" . ?s))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

** Daily questions
:PROPERTIES:
:ID:       5cf852d3-a30a-4216-876d-f5859c92add0
:END:
In my capture template for daily questions, I want to copy in the latest set of
daily questions I have (See [[https://amzn.com/0804141231][Triggers]]). this function helps facilitate that.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun jm/daily-qs ()
    (save-excursion
      (org-id-goto jm/daily-qs-id)
      (org-copy-subtree)
      (current-kill 0 :t)))

#+END_SRC
** "GTD Stuff"
:PROPERTIES:
:ID:       ae3dab52-99e9-4819-8b30-6f0377d00e70
:END:

#+begin_src emacs-lisp :tangle yes
(setq org-stuck-projects (quote ("" nil nil "")))

  (defun jm/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun jm/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (jm/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun jm/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun jm/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun jm/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun jm/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar jm/hide-scheduled-and-waiting-next-tasks t)

  (defun jm/toggle-next-task-display ()
    (interactive)
    (setq jm/hide-scheduled-and-waiting-next-tasks (not jm/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if jm/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun jm/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (jm/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun jm/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    (jm/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (jm/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun jm/skip-non-projects ()
    "Skip trees that are not projects"
    (jm/list-sublevels-for-projects-indented)
    (if (save-excursion (jm/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((jm/is-project-p)
              nil)
             ((and (jm/is-project-subtree-p) (not (jm/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun jm/skip-non-tasks ()
    "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((jm/is-task-p)
          nil)
         (t
          next-headline)))))

  (defun jm/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((jm/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun jm/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and jm/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((jm/is-project-p)
          next-headline)
         ((and (jm/is-task-p) (not (jm/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun jm/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((jm/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (jm/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (jm/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun jm/skip-project-tasks ()
    "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((jm/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((jm/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun jm/skip-non-project-tasks ()
    "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((jm/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (jm/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (jm/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun jm/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((jm/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun jm/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (jm/is-subproject-p)
          nil
        next-headline)))


#+end_src
** Babel (and export)
:PROPERTIES:
:ID:       1754fd8f-c7da-4837-89b4-a9f9c8c1fe2d
:END:
code in blocks.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)

; Make babel results blocks lowercase
(setq org-babel-results-keyword "results")

(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))
#+END_SRC
** Reminders
:PROPERTIES:
:ID:       cae73a8f-a109-4e88-b776-b13afcf3d9f3
:END:
This sets up automatic meeting reminders within your emacs client, using appt.el.
#+BEGIN_SRC emacs-lisp :tangle yes
; Erase all reminders and rebuilt reminders for today from the agenda
(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-agenda-finalize-hook 'bh/org-agenda-to-appt 'append)

; This is at the end of my .emacs - so appointments are set up when Emacs starts
(bh/org-agenda-to-appt)

; Activate appointments so we get notifications
(appt-activate t)

; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)
#+END_SRC
** Other
:PROPERTIES:
:ID:       db1a5ed4-f7d4-4227-9b03-406041e251a1
:END:
some more things...
#+begin_src emacs-lisp :tangle yes
  (defun jm/hide-other ()
    (interactive)
    (save-excursion
      (org-back-to-heading 'invisible-ok)
      (hide-other)
      (org-cycle)
      (org-cycle)
      (org-cycle)))

  (defun jm/set-truncate-lines ()
    "Toggle value of truncate-lines and refresh window display."
    (interactive)
    (setq truncate-lines (not truncate-lines))
    ;; now refresh window display (an idiom from simple.el):
    (save-excursion
      (set-window-start (selected-window)
                        (window-start (selected-window)))))

  (defun jm/make-org-scratch ()
    (interactive)
    (find-file "/tmp/publish/scratch.org")
    (gnus-make-directory "/tmp/publish"))

  (defun jm/switch-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))

#+end_src
** Keybindings
:PROPERTIES:
:ID:       2958add2-0a7d-4021-a69d-0ff5ef9f235c
:END:
Some top-level keybindings.
#+BEGIN_SRC emacs-lisp :tangle yes

  (map! :leader
        :prefix "n"
        :desc "Org Agenda" "A" #'jm/org-agenda)
#+END_SRC


A clocking menu. I'd like to move this into the notes menu -- it came up after I
crated this.

#+BEGIN_SRC emacs-lisp :tangle yes
(map! :leader
      :desc "Clock" :prefix ("C" . "Clock")
      :desc "Clock In" :n "I" #'org-clock-in
      :desc "Go to Clock" :n "g" #'org-clock-goto
      :desc "Punch In" :n "i" #'jm/punch-in
      :desc "Punch Out" :n "o" #'jm/punch-out
      :desc "Clock in last task used" :n "l" #'jm/clock-in-last-task)

#+END_SRC
** End of GTD
:PROPERTIES:
:ID:       aee68b09-c853-4b03-b4ee-a3ef70f9fb5b
:END:
(cap off the ~(after! org~ in the introduction.)
#+begin_src emacs-lisp :tangle yes
)
#+end_src
* Miscellaneous
:PROPERTIES:
:ID:       95aaeba1-72ed-4383-9c7d-3852f3bf8670
:END:
Things I'm still trying out. :+1:
#+begin_src emacs-lisp :tangle yes
(use-package! emoji-cheat-sheet-plus)
(if (featurep! :completion company)
    (use-package! company-emoji
      :defer t
      :init (setq company-emoji-insert-unicode nil)))

(map! :leader
      :prefix "i"
      :desc "emoji buffer" "E" #'emoji-cheat-sheet-plus-buffer
      :desc "emoji insert" "e" #'emoji-cheat-sheet-plus-insert
      )

;; (use-package! org-habit)
;; (use-package! org-protocol)

#+end_src
** Library of Babel
:PROPERTIES:
:ID:       91d0412b-a287-4428-af38-9b40a389da7c
:END:
I make a decent use of org-mode, and particularly org-babel. A nice feature
of that is being able to define a library of functions and call them from
separate files.

#+begin_src emacs-lisp :tangle yes
  (dolist (element (directory-files-recursively "~/.doom.d/lob/" ""))
    (org-babel-lob-ingest element))
#+end_src


** compat
This may be some sort of dependency for magit now. Let me try pulling it in.
#+begin_src emacs-lisp :tangle yes
(use-package! compat)
#+end_src
** keychain-environment
#+begin_src emacs-lisp :tangle yes
(use-package! keychain-environment)
#+end_src
